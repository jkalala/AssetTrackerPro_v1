import { createClient } from '@/lib/supabase/server';
import {
  DepreciationScheduleEntry,
  BudgetVariance,
  ROIAnalysis,
  TCOAnalysis,
  FinancialAlert,
  DepreciationCalculationRequest,
  DepreciationCalculationResult,
  TCOCalculationRequest,
  ROICalculationRequest,
  BudgetVarianceAnalysisRequest,
  FinancialDashboardData,
  FinancialReportFilters,
  CostAnalysisResult,
  DepreciationSummary,
  DepreciationMethod,
  CostCategory,
  VarianceType
} from '@/lib/types/financial';

export class FinancialAnalyticsService {
  private supabase: any;

  constructor() {
    this.supabase = createClient();
  }

  // Depreciation Calculation Engine
  async calculateDepreciation(request: DepreciationCalculationRequest): Promise<DepreciationCalculationResult> {
    const { method, purchasePrice, salvageValue, usefulLifeYears, usefulLifeUnits, startDate, endDate, unitsProduced } = request;
    
    const schedule: DepreciationScheduleEntry[] = [];
    let accumulatedDepreciation = 0;
    let currentBookValue = purchasePrice;
    
    const analysisEndDate = endDate || new Date();
    const depreciableAmount = purchasePrice - salvageValue;
    
    switch (method) {
      case 'straight_line':
        if (!usefulLifeYears) throw new Error('Useful life years required for straight line method');
        
        const annualDepreciation = depreciableAmount / usefulLifeYears;
        const monthlyDepreciation = annualDepreciation / 12;
        
        let currentDate = new Date(startDate);
        while (currentDate <= analysisEndDate) {
          const periodEndDate = new Date(currentDate);
          periodEndDate.setMonth(periodEndDate.getMonth() + 1);
          
          const depreciationAmount = Math.min(monthlyDepreciation, currentBookValue - salvageValue);
          accumulatedDepreciation += depreciationAmount;
          currentBookValue -= depreciationAmount;
          
          schedule.push({
            id: '', // Will be generated by database
            tenantId: '', // Will be set by caller
            assetFinancialId: request.assetFinancialId,
            periodStartDate: new Date(currentDate),
            periodEndDate: periodEndDate,
            depreciationAmount,
            accumulatedDepreciation,
            bookValue: currentBookValue,
            createdAt: new Date()
          });
          
          currentDate = periodEndDate;
        }
        break;
        
      case 'declining_balance':
        if (!usefulLifeYears) throw new Error('Useful life years required for declining balance method');
        
        const declineRate = 1 / usefulLifeYears;
        let currentDate2 = new Date(startDate);
        
        while (currentDate2 <= analysisEndDate && currentBookValue > salvageValue) {
          const periodEndDate = new Date(currentDate2);
          periodEndDate.setMonth(periodEndDate.getMonth() + 1);
          
          const depreciationAmount = Math.min(currentBookValue * declineRate / 12, currentBookValue - salvageValue);
          accumulatedDepreciation += depreciationAmount;
          currentBookValue -= depreciationAmount;
          
          schedule.push({
            id: '',
            tenantId: '',
            assetFinancialId: request.assetFinancialId,
            periodStartDate: new Date(currentDate2),
            periodEndDate: periodEndDate,
            depreciationAmount,
            accumulatedDepreciation,
            bookValue: currentBookValue,
            createdAt: new Date()
          });
          
          currentDate2 = periodEndDate;
        }
        break;
        
      case 'double_declining_balance':
        if (!usefulLifeYears) throw new Error('Useful life years required for double declining balance method');
        
        const doubleDeclineRate = 2 / usefulLifeYears;
        let currentDate3 = new Date(startDate);
        
        while (currentDate3 <= analysisEndDate && currentBookValue > salvageValue) {
          const periodEndDate = new Date(currentDate3);
          periodEndDate.setMonth(periodEndDate.getMonth() + 1);
          
          const depreciationAmount = Math.min(currentBookValue * doubleDeclineRate / 12, currentBookValue - salvageValue);
          accumulatedDepreciation += depreciationAmount;
          currentBookValue -= depreciationAmount;
          
          schedule.push({
            id: '',
            tenantId: '',
            assetFinancialId: request.assetFinancialId,
            periodStartDate: new Date(currentDate3),
            periodEndDate: periodEndDate,
            depreciationAmount,
            accumulatedDepreciation,
            bookValue: currentBookValue,
            createdAt: new Date()
          });
          
          currentDate3 = periodEndDate;
        }
        break;
        
      case 'sum_of_years_digits':
        if (!usefulLifeYears) throw new Error('Useful life years required for sum of years digits method');
        
        const sumOfYears = (usefulLifeYears * (usefulLifeYears + 1)) / 2;
        let currentDate4 = new Date(startDate);
        let yearNumber = 1;
        
        while (currentDate4 <= analysisEndDate && yearNumber <= usefulLifeYears) {
          const yearEndDate = new Date(currentDate4);
          yearEndDate.setFullYear(yearEndDate.getFullYear() + 1);
          
          const remainingYears = usefulLifeYears - yearNumber + 1;
          const yearlyDepreciation = (remainingYears / sumOfYears) * depreciableAmount;
          const monthlyDepreciation = yearlyDepreciation / 12;
          
          for (let month = 0; month < 12 && currentDate4 <= analysisEndDate; month++) {
            const periodEndDate = new Date(currentDate4);
            periodEndDate.setMonth(periodEndDate.getMonth() + 1);
            
            const depreciationAmount = Math.min(monthlyDepreciation, currentBookValue - salvageValue);
            accumulatedDepreciation += depreciationAmount;
            currentBookValue -= depreciationAmount;
            
            schedule.push({
              id: '',
              tenantId: '',
              assetFinancialId: request.assetFinancialId,
              periodStartDate: new Date(currentDate4),
              periodEndDate: periodEndDate,
              depreciationAmount,
              accumulatedDepreciation,
              bookValue: currentBookValue,
              createdAt: new Date()
            });
            
            currentDate4 = periodEndDate;
          }
          
          yearNumber++;
        }
        break;
        
      case 'units_of_production':
        if (!usefulLifeUnits || !unitsProduced) {
          throw new Error('Useful life units and units produced required for units of production method');
        }
        
        const depreciationPerUnit = depreciableAmount / usefulLifeUnits;
        const totalDepreciationAmount = Math.min(unitsProduced * depreciationPerUnit, depreciableAmount);
        
        accumulatedDepreciation = totalDepreciationAmount;
        currentBookValue = purchasePrice - accumulatedDepreciation;
        
        schedule.push({
          id: '',
          tenantId: '',
          assetFinancialId: request.assetFinancialId,
          periodStartDate: startDate,
          periodEndDate: analysisEndDate,
          depreciationAmount: totalDepreciationAmount,
          accumulatedDepreciation,
          bookValue: currentBookValue,
          unitsProduced,
          createdAt: new Date()
        });
        break;
    }
    
    return {
      schedule,
      totalDepreciation: accumulatedDepreciation,
      currentBookValue,
      accumulatedDepreciation
    };
  }

  // TCO Analysis
  async calculateTCO(request: TCOCalculationRequest): Promise<TCOAnalysis> {
    const {
      assetId,
      analysisPeriodYears,
      purchasePrice,
      installationCost = 0,
      trainingCost = 0,
      initialSetupCost = 0,
      maintenanceCostAnnual = 0,
      energyCostAnnual = 0,
      insuranceCostAnnual = 0,
      storageCostAnnual = 0,
      laborCostAnnual = 0,
      disposalCost = 0,
      salvageValue = 0
    } = request;

    const totalAcquisitionCost = purchasePrice + installationCost + trainingCost + initialSetupCost;
    const totalOperatingCost = (maintenanceCostAnnual + energyCostAnnual + insuranceCostAnnual + storageCostAnnual + laborCostAnnual) * analysisPeriodYears;
    const totalEndOfLifeCost = disposalCost - salvageValue;
    const totalCostOfOwnership = totalAcquisitionCost + totalOperatingCost + totalEndOfLifeCost;

    const tcoAnalysis: Omit<TCOAnalysis, 'id' | 'tenantId' | 'createdBy' | 'createdAt'> = {
      assetId,
      analysisPeriodYears,
      analysisDate: new Date(),
      purchasePrice,
      installationCost,
      trainingCost,
      initialSetupCost,
      maintenanceCostAnnual,
      energyCostAnnual,
      insuranceCostAnnual,
      storageCostAnnual,
      laborCostAnnual,
      disposalCost,
      salvageValue,
      totalAcquisitionCost,
      totalOperatingCost,
      totalEndOfLifeCost,
      totalCostOfOwnership,
      tcoPerYear: totalCostOfOwnership / analysisPeriodYears,
      tcoPerMonth: totalCostOfOwnership / (analysisPeriodYears * 12)
    };

    return tcoAnalysis as TCOAnalysis;
  }

  // ROI Analysis
  async calculateROI(request: ROICalculationRequest): Promise<ROIAnalysis> {
    const {
      assetId,
      analysisPeriodStart,
      analysisPeriodEnd,
      initialInvestment,
      additionalInvestments = 0,
      revenueGenerated = 0,
      costSavings = 0,
      productivityGains = 0,
      utilizationPercentage,
      downtimeHours = 0,
      maintenanceHours = 0
    } = request;

    const totalInvestment = initialInvestment + additionalInvestments;
    const totalReturns = revenueGenerated + costSavings + productivityGains;
    const netReturn = totalReturns - totalInvestment;
    const roiPercentage = totalInvestment > 0 ? (netReturn / totalInvestment) * 100 : 0;

    // Calculate payback period in months
    let paybackPeriodMonths: number | undefined;
    if (totalReturns > 0) {
      const monthlyReturn = totalReturns / 12; // Assuming annual returns
      paybackPeriodMonths = Math.ceil(totalInvestment / monthlyReturn);
    }

    const roiAnalysis: Omit<ROIAnalysis, 'id' | 'tenantId' | 'createdBy' | 'createdAt'> = {
      assetId,
      analysisPeriodStart,
      analysisPeriodEnd,
      initialInvestment,
      additionalInvestments,
      totalInvestment,
      revenueGenerated,
      costSavings,
      productivityGains,
      totalReturns,
      netReturn,
      roiPercentage,
      paybackPeriodMonths,
      utilizationPercentage,
      downtimeHours,
      maintenanceHours
    };

    return roiAnalysis as ROIAnalysis;
  }

  // Budget Variance Analysis
  async analyzeBudgetVariance(request: BudgetVarianceAnalysisRequest): Promise<BudgetVariance[]> {
    const { budgetId, periodStart, periodEnd, lineItemId } = request;

    // Get budget and line items
    let query = this.supabase
      .from('budget_line_items')
      .select('*')
      .eq('budget_id', budgetId);

    if (lineItemId) {
      query = query.eq('id', lineItemId);
    }

    const { data: lineItems, error: lineItemsError } = await query;
    if (lineItemsError) throw lineItemsError;

    const variances: BudgetVariance[] = [];

    for (const lineItem of lineItems || []) {
      // Calculate actual spending for the period
      const { data: costs, error: costsError } = await this.supabase
        .from('asset_costs')
        .select('cost_amount')
        .eq('cost_category', lineItem.cost_category)
        .gte('cost_date', periodStart.toISOString().split('T')[0])
        .lte('cost_date', periodEnd.toISOString().split('T')[0]);

      if (costsError) throw costsError;

      const actualAmount = costs?.reduce((sum: number, cost: Record<string, unknown>) => sum + cost.cost_amount, 0) || 0;
      const budgetedAmount = lineItem.budgeted_amount;
      const varianceAmount = actualAmount - budgetedAmount;
      const variancePercentage = budgetedAmount > 0 ? (varianceAmount / budgetedAmount) * 100 : 0;

      let varianceType: VarianceType = 'neutral';
      if (varianceAmount > 0) {
        varianceType = 'unfavorable';
      } else if (varianceAmount < 0) {
        varianceType = 'favorable';
      }

      variances.push({
        id: '', // Will be generated by database
        tenantId: lineItem.tenant_id,
        budgetId,
        budgetLineItemId: lineItem.id,
        analysisDate: new Date(),
        periodStart,
        periodEnd,
        budgetedAmount,
        actualAmount,
        varianceAmount,
        variancePercentage,
        varianceType,
        createdBy: '', // Will be set by caller
        createdAt: new Date()
      });
    }

    return variances;
  }

  // Financial Dashboard Data
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async getFinancialDashboardData(tenantId: string, _filters?: FinancialReportFilters): Promise<FinancialDashboardData> {
    // Get total asset value
    const { data: assetFinancialData, error: assetError } = await this.supabase
      .from('asset_financial_data')
      .select('current_book_value, purchase_price')
      .eq('tenant_id', tenantId);

    if (assetError) throw assetError;

    const totalAssetValue = assetFinancialData?.reduce((sum: number, asset: Record<string, unknown>) => 
      sum + (asset.current_book_value || asset.purchase_price || 0), 0) || 0;

    // Get total depreciation
    const { data: depreciationData, error: depreciationError } = await this.supabase
      .from('depreciation_schedule')
      .select('accumulated_depreciation')
      .eq('tenant_id', tenantId)
      .order('period_end_date', { ascending: false })
      .limit(1);

    if (depreciationError) throw depreciationError;

    const totalDepreciation = depreciationData?.[0]?.accumulated_depreciation || 0;

    // Get maintenance costs
    const { data: maintenanceCosts, error: maintenanceError } = await this.supabase
      .from('asset_costs')
      .select('cost_amount')
      .eq('tenant_id', tenantId)
      .eq('cost_category', 'maintenance');

    if (maintenanceError) throw maintenanceError;

    const totalMaintenanceCosts = maintenanceCosts?.reduce((sum: number, cost: Record<string, unknown>) => sum + cost.cost_amount, 0) || 0;

    // Get budget utilization
    const { data: budgets, error: budgetError } = await this.supabase
      .from('budgets')
      .select('total_budget, spent_amount')
      .eq('tenant_id', tenantId)
      .eq('status', 'active');

    if (budgetError) throw budgetError;

    const totalBudget = budgets?.reduce((sum: number, budget: Record<string, unknown>) => sum + budget.total_budget, 0) || 0;
    const totalSpent = budgets?.reduce((sum: number, budget: Record<string, unknown>) => sum + budget.spent_amount, 0) || 0;
    const budgetUtilization = totalBudget > 0 ? (totalSpent / totalBudget) * 100 : 0;

    // Get average ROI
    const { data: roiData, error: roiError } = await this.supabase
      .from('roi_analysis')
      .select('roi_percentage')
      .eq('tenant_id', tenantId);

    if (roiError) throw roiError;

    const averageROI = roiData?.length > 0 
      ? roiData.reduce((sum: number, roi: Record<string, unknown>) => sum + roi.roi_percentage, 0) / roiData.length 
      : 0;

    // Get top cost categories
    const { data: costsByCategory, error: costError } = await this.supabase
      .from('asset_costs')
      .select('cost_category, cost_amount')
      .eq('tenant_id', tenantId);

    if (costError) throw costError;

    const categoryTotals: Record<CostCategory, number> = {} as Record<CostCategory, number>;
    costsByCategory?.forEach((cost: Record<string, unknown>) => {
      (categoryTotals as any)[cost.cost_category] = ((categoryTotals as any)[cost.cost_category] || 0) + cost.cost_amount;
    });

    const totalCosts = Object.values(categoryTotals).reduce((sum: number, amount: Record<string, unknown>) => sum + amount, 0);
    const topCostCategories = Object.entries(categoryTotals)
      .map(([category, amount]) => ({
        category: category as CostCategory,
        amount,
        percentage: totalCosts > 0 ? (amount / totalCosts) * 100 : 0
      }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 5);

    return {
      totalAssetValue,
      totalDepreciation,
      totalMaintenanceCosts,
      budgetUtilization,
      averageROI,
      topCostCategories,
      budgetVariances: [], // Would be populated with recent variances
      upcomingDepreciationMilestones: [] // Would be populated with upcoming milestones
    };
  }

  // Cost Analysis
  async analyzeCosts(tenantId: string, filters: FinancialReportFilters): Promise<CostAnalysisResult> {
    let query = this.supabase
      .from('asset_costs')
      .select('*, assets(name)')
      .eq('tenant_id', tenantId)
      .gte('cost_date', filters.dateRange.start.toISOString().split('T')[0])
      .lte('cost_date', filters.dateRange.end.toISOString().split('T')[0]);

    if (filters.assetIds?.length) {
      query = query.in('asset_id', filters.assetIds);
    }

    if (filters.costCategories?.length) {
      query = query.in('cost_category', filters.costCategories);
    }

    const { data: costs, error } = await query;
    if (error) throw error;

    const totalCosts = costs?.reduce((sum: number, cost: Record<string, unknown>) => sum + cost.cost_amount, 0) || 0;

    // Group by category
    const costsByCategory: Record<CostCategory, number> = {} as Record<CostCategory, number>;
    costs?.forEach((cost: Record<string, unknown>) => {
      costsByCategory[cost.cost_category] = (costsByCategory[cost.cost_category] || 0) + cost.cost_amount;
    });

    // Group by month
    const costsByMonth: Array<{ month: string; amount: number }> = [];
    const monthlyTotals: Record<string, number> = {};
    
    costs?.forEach((cost: Record<string, unknown>) => {
      const month = new Date(cost.cost_date).toISOString().slice(0, 7); // YYYY-MM
      monthlyTotals[month] = (monthlyTotals[month] || 0) + cost.cost_amount;
    });

    Object.entries(monthlyTotals)
      .sort(([a], [b]) => a.localeCompare(b))
      .forEach(([month, amount]) => {
        costsByMonth.push({ month, amount });
      });

    // Top assets by cost
    const assetTotals: Record<string, { name: string; total: number }> = {};
    costs?.forEach((cost: Record<string, unknown>) => {
      if (!assetTotals[cost.asset_id]) {
        assetTotals[cost.asset_id] = {
          name: cost.assets?.name || 'Unknown Asset',
          total: 0
        };
      }
      assetTotals[cost.asset_id].total += cost.cost_amount;
    });

    const topAssetsByCost = Object.entries(assetTotals)
      .map(([assetId, data]) => ({
        assetId,
        assetName: data.name,
        totalCost: data.total
      }))
      .sort((a, b) => b.totalCost - a.totalCost)
      .slice(0, 10);

    return {
      totalCosts,
      costsByCategory,
      costsByMonth,
      topAssetsByCost
    };
  }

  // Depreciation Summary
  async getDepreciationSummary(tenantId: string): Promise<DepreciationSummary> {
    const { data: assetFinancialData, error: assetError } = await this.supabase
      .from('asset_financial_data')
      .select('purchase_price, current_book_value, depreciation_method')
      .eq('tenant_id', tenantId);

    if (assetError) throw assetError;

    const totalOriginalValue = assetFinancialData?.reduce((sum: number, asset: Record<string, unknown>) => sum + asset.purchase_price, 0) || 0;
    const totalCurrentValue = assetFinancialData?.reduce((sum: number, asset: Record<string, unknown>) => sum + (asset.current_book_value || asset.purchase_price), 0) || 0;
    const totalDepreciation = totalOriginalValue - totalCurrentValue;

    // Group by depreciation method
    const depreciationByMethod: Record<DepreciationMethod, number> = {} as Record<DepreciationMethod, number>;
    assetFinancialData?.forEach((asset: Record<string, unknown>) => {
      const depreciation = asset.purchase_price - (asset.current_book_value || asset.purchase_price);
      depreciationByMethod[asset.depreciation_method] = (depreciationByMethod[asset.depreciation_method] || 0) + depreciation;
    });

    // Get monthly depreciation
    const { data: monthlyDepreciation, error: monthlyError } = await this.supabase
      .from('depreciation_schedule')
      .select('period_start_date, depreciation_amount')
      .eq('tenant_id', tenantId)
      .order('period_start_date');

    if (monthlyError) throw monthlyError;

    const monthlyTotals: Record<string, number> = {};
    monthlyDepreciation?.forEach((entry: Record<string, unknown>) => {
      const month = new Date(entry.period_start_date).toISOString().slice(0, 7);
      monthlyTotals[month] = (monthlyTotals[month] || 0) + entry.depreciation_amount;
    });

    const monthlyDepreciationArray = Object.entries(monthlyTotals)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([month, amount]) => ({ month, amount }));

    return {
      totalOriginalValue,
      totalCurrentValue,
      totalDepreciation,
      depreciationByMethod,
      monthlyDepreciation: monthlyDepreciationArray
    };
  }

  // Alert Management
  async checkFinancialAlerts(tenantId: string): Promise<void> {
    const { data: alerts, error } = await this.supabase
      .from('financial_alerts')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('is_active', true);

    if (error) throw error;

    for (const alert of alerts || []) {
      await this.evaluateAlert(alert);
    }
  }

  private async evaluateAlert(alert: FinancialAlert): Promise<void> {
    let shouldTrigger = false;
    let alertValue: number | undefined;

    switch (alert.alertType) {
      case 'budget_variance':
        if (alert.budgetId) {
          // Check budget variance
          const variance = await this.getBudgetVariance(alert.budgetId);
          alertValue = Math.abs(variance.variancePercentage);
          shouldTrigger = this.compareValues(alertValue, alert.thresholdPercentage || 0, alert.comparisonOperator);
        }
        break;

      case 'depreciation_milestone':
        // Check depreciation milestones
        if (alert.assetIds?.length) {
          for (const assetId of alert.assetIds) {
            const depreciation = await this.getAssetDepreciationPercentage(assetId);
            alertValue = depreciation;
            if (this.compareValues(alertValue, alert.thresholdPercentage || 0, alert.comparisonOperator)) {
              shouldTrigger = true;
              break;
            }
          }
        }
        break;

      case 'roi_threshold':
        // Check ROI thresholds
        if (alert.assetIds?.length) {
          for (const assetId of alert.assetIds) {
            const roi = await this.getAssetROI(assetId);
            alertValue = roi;
            if (this.compareValues(alertValue, alert.thresholdPercentage || 0, alert.comparisonOperator)) {
              shouldTrigger = true;
              break;
            }
          }
        }
        break;
    }

    if (shouldTrigger) {
      await this.triggerAlert(alert, alertValue);
    }
  }

  private compareValues(value: number, threshold: number, operator: string): boolean {
    switch (operator) {
      case 'gt': return value > threshold;
      case 'gte': return value >= threshold;
      case 'lt': return value < threshold;
      case 'lte': return value <= threshold;
      case 'eq': return value === threshold;
      default: return false;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private async getBudgetVariance(_budgetId: string): Promise<{ variancePercentage: number }> {
    // Implementation would fetch latest budget variance
    return { variancePercentage: 0 };
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private async getAssetDepreciationPercentage(_assetId: string): Promise<number> {
    // Implementation would calculate current depreciation percentage
    return 0;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private async getAssetROI(_assetId: string): Promise<number> {
    // Implementation would fetch latest ROI analysis
    return 0;
  }

  private async triggerAlert(alert: FinancialAlert, alertValue?: number): Promise<void> {
    // Record alert trigger
    await this.supabase
      .from('financial_alert_history')
      .insert({
        tenant_id: alert.tenantId,
        alert_id: alert.id,
        triggered_at: new Date().toISOString(),
        alert_value: alertValue,
        threshold_value: alert.thresholdValue || alert.thresholdPercentage,
        notifications_sent: {}
      });

    // Update last triggered timestamp
    await this.supabase
      .from('financial_alerts')
      .update({ last_triggered_at: new Date().toISOString() })
      .eq('id', alert.id);

    // Send notifications (implementation would depend on notification service)
    // await this.sendAlertNotifications(alert, alertValue);
  }
}